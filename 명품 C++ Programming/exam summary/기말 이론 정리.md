# 클래스와 객체
#### 객체에 대한 이해
```markdown
1. 실세계는 객체들의 집합이며 객체들이 상호 통신하는 시스템이다.
2. 캡슐화는 객체를 캡슐로 싸서 그 내부를 볼 수 없게 하고 외부의 접근으로부터 보호한다.
3. C++ 객체는 멤버 변수와 멤버 함수로 구성되며. 멤버 변수는 객체의 상태(state)을. 멤버 함수는 객체의 행동을 표현한다.
4. C++ 클래스는 객체를 정의하는 틀 혹은 설계도로서 사용자는 클래스로 새로운 데이터 타입을 선언한다.C++ 객체는 실행 중에 생성되어 존재하므로 실체(instance)라고도 부른다.
```
#### C++ 클래스 만들기
```markdown
1. class 키워드를 이용하여 클래스를 선언한다. 클래스 선언 뒤에는 반드시 세미콜론을 붙인다
2. 클래스는 선언부와 구현부로 나누어 작성하는 것이 원칙이다. 클래스 구현부는 클래스 선언부에 선언된 함수들의 코드를 구현하는 부분이다.
3. 객체의 멤버 접근은 '객체.멤버' 형식을 사용한다.
```
#### 생성자
```markdown
1. 생성자는 클래스의 이름과 동일한 멤버 함수로서 객체가 생성될 때 한 번만 실행되는 특별한 멤버이다.
2. 생성자는 객체의 초기화에 사용되며, 리턴 타입이 없고 중복이 가능하다.
3. 기본 생성자는 디폴트 생성자라고도 불리며 매개 변수 없는 생성자이다. 아무생성자도 선언되어 있지 않으면, 컴파일러가 기본생성자를 자동으로 삽입한다. 기본생성자는 단순 리턴한다.
```
#### 소멸자
```markdown
1. 소멸자는 객체가 소멸될 때 실행되는멤버함수로서 클래스의 이름앞에 ~를 붙인 이름으로 선언되어야 한다.
2. 소멸자는 매개변수를 가지지 않고 리턴 타입도 없으며, 중복이 불가능하다. 
3. 객체는 생성된 반대순으로 소멸된다.
```
#### 접근지정
```markdown
1. 접근 지정이란 객체를 캡슐화함에 따라 외부에서 접근가능한 멤버와 접근할 수 없는 멤버를 선언하는 지시이다.
2. 멤버의 접근 지정은 private, public, protected의 세가지가 있다.
3. private 멤버는 클래스 내부의 함수들만 접근할 수 있는 멤버이고, public 멤버는 클래스 내외의 무든 함수들이 접근할 수 있는 멤버이며, protected 멤버는 자식 클래스에서만 접근할 수 있는 멤버이다.
4. C++ 클래스의 디폴트 접근 지정은 private이므로 접근 지정이 생략되면 private로 처리 된다.
```
#### 인라인 함수
```markdown
1. 함수에 inline 키워드를 붙혀 인라인으로 선언하면, 컴파일러는 인라인 함수의 코드를 함수를 호출하는 곳에 확장시킨다. 그러므로 함수 호출이 일어나지 않고, 함수 호출에 대한 오버헤드를 제거하여 실행 속도를 높인다.
2. 인라인은 클래스의 멤버 함수나 외부 함수 모두 가능하며, 클래스 내의 선언부에 작성된 함수는 컴파일러에 의해 자동으로 인라인 처리 된다.
```

# 객체 포인터와 배열,  동적 생성
#### 객체 포인터
```markdown
1. C++에서는 객체의 주소를 가지는 객체 포인터를 선언하고 활용할 수 있다.
2. 객체 포인터로 객체의 멤버에 접근할 때 ->연산자를 사용한다.
3. 초기화 되지 않는 객체 포인터를 사용하면 null pointer assignment 실행 오류가 발생한다.
```
#### 객체  배열
```markdown
1. 객체 배열의 선언 및 활용 방법은 기본 타입 배열과 동일하다.
2. 객체 배열이 생성될 때 배열의 각 원소 객체마다 기본생성자가 실행되며, 배열이 소멸될 때 각 원소 객체마다 소멸자가 실행 된다. 원소 객체는 인덱스가 높은 곳에서 낮은 순으로 소멸된다.
```
#### 동적 메모리 할당 및 반환
```markdown
1. new 연산자로 동적 메모리를 할당 받고, delete 연산자로 할당받은 메모리를  반환한다.
2. new로 기본 타입의 배열을 할당 받고 delete로 소멸할 수 있다.
3. new와 delete는 기본연산자 이다.
```
#### 객체와 객체 배열의 동적 생성 및 반환
```markdown
1. new 와 delete를 이용하여 객체를 할당 받고 반환할 때 생성자와 소멸자가 각각 실행된다.
2. new와 delete를 이용하여 객체 배열을 할당 받고 반활할 수 있으며, 이때 배열의 각 객체마다 생성자와 소멸자가 실행되고, 소멸자는 생성된 반대순으로 실행된다.
3. new로 객체 배열을 생성할 때는 기본 생성자가 호출된다.
4. new로 할당 받은 메모리는 실행 중에 delete를 이용하여 반환하지 않는 한 시스템에 반환 되지 않는다. 동적으로 할당 받은 메모리에 대한 주소를 잃어버리게 되면, 메모리 누수가 발생한다. 프로그램이 종료하면 동적으로 할당 받은 메모리는 자동 반환 된다.
```
#### this 포인터
```markdown
1. this는 객체 자신에 대한 포인터이다.
2. 객체의 멤버 함수가 호출될 때 컴파일러는 객체의 주소를 멤버 함수에 묵시적으로 전달하며, this는 이 주소를 받도록 컴파일러에 의해 몰래 삽입된 매개 변수의 이름이다.
3. 클래스의 non-static멤버 함수에서만 사용할 수 있다.
```
#### string 클래스를 이용한 문자열 사용
```markdown
1. string 클래스는 C++표준 라이브러리에 포함된 것으로 문자열을 다루는 클래스이다. 
2. string 클래스는 문자열의 길이에 따라 문자열을 저장하는 내부 메모리의 크기를 자동으로 조절하므로 사용하기 편리하고, 문자열 조작을 위한 많은 멤버 함수와 연산자 함수를 제공한다.
3. 문자열을 키보드로부터 입력 받기 위해 string헤더 파일에 선언된 getline() 전역 함수를 이용하면, 공백 문자를 포함하는 문자열을 입력받을 수 있다.
4. stoi() 함수를 이용하면 문자열을 숫자로 변환할 수 있다.
```
# 함수와 참조, 복사 생성자
#### C++ 인자 전달 방식
```markdown
 1. 값에 의한 호출, 주소에 의한 호출, 참조에 의한 호출 의 3가지가 있다.
 2. 값에 의한 호출 시 실인자의 값이 매개변수에 복사 되어 전달되므로, 매개 변수와 실인자는 메모리를 서로 공유 하지 않는다. 그로므로 함수 내에서 매개 변수의 값을 변경해도 실인자의 값이 바뀌지 않는다. 객체가 값에의한 호출로 전달되면 매개 변수 객체의 생성자는 실행되지 않고 소멸자만 실행 되는 문제가 발생한다.
 3. 참조에 의한 호출 은 원본에 대한 참조만 전달되므로 함수 내에서 참조 매개변수를 이용하여 원본 데이터를 읽고 수정할 수 있다.
```
#### 객체 치환 및 객체 리턴
```markdown
1. 치환 연산자로 객체를 치환하면, 비트 단위로 객체가 복사된다.
2. C++ 함수는 객체를 리턴할 수 있다. 이때 객체의 복사본이 만들어져 리턴된다.
```

#### 참조와 함수
```markdown
1. 참조란 가리킨다 란 뜻이며, 참조 변수는 이미 존재하는 변수에 붙여진 별명이다
2. 참조 변수의 선언으로 변수 이름만 생기고 변수 공간이 할당되지 않는다.
3. 참조는 포인터가 아니며, C++뿐 아니라 PASCAL등 다른 언어에도 있다.
4. 참조 변수는 참조자(&)를 사용하여 선언되며, 반드시 기존 변수로 초기화 되어야 한다.
5. 참조 타입의 매개 변수를 가진 함수에 대한 호출을 참조에 의한 호출 이라고 부른다
6. C++에서 참조를 리턴하는 함수를 작성할 수 있다.
```
#### 깊은 복사 얕은 복사
```markdown
1. 복사에는 얕은 복사와 깊은 복사의 두 종류가 있다. 얕은 복사는 객체의 멤버를 1:1로 단순 복사하지만. 깊은 복사는 객체의 멤버 포인터가 할당 받은 메모리까지 복사하는 완전한 형태의 복사이다.
2. 복사 생성은 객체를 생성할 때 원본 객체를 복사하여 생성하는 것을 말한다.
3. 묵시적으로 복사 생성이 일어나는 경우는 다음 3가지이다.
	SampleClass s = y; 			//객체 x 가 y로 초기화 되어 생성
	void f(SampleClass x){} 	//함수 f()가 호출되어 객체  x가 생길 때
	SampleClass f() {SampleClass x; return x;} //함수가 객체를 리턴할 때
```
#### 복사 생성자
```markdown
1. 복사 생성자는 객체의 복사 생성 시에 호출 되는 특별한 원형의 생성자로서, 하나의 매개변수만을 가지며, 매개 변수는 클래스에 대한 참조 타입이다.
2. 복사 생성자가 작성되지 않은 클래스의 경우 컴파일러가 디폴트 복사 생성자를 자동 삽입하며, 디폴트 복사 생성자는 앝은 복사를 실행한다.
3. 클래스에 포인터 변수 멤버가 있는 경우, 디폴트 복사 생성자와 같이 얕은 복사 생성자를 사용하면 포인터가 가진 메모리를 원본과 사본 객체가 공유하는 문제가 생기고, 프로그렘이 비정상 종료되기도 하므로 깊은 복사 생성자를 반드시 작성하는 것이 좋다.
```

# 함수 중복과 static 멤버
#### 함수 중복
```markdown
1. C++에서는 같은 이름의 함수를 여러 개 작성할 수 있는 함수 중복을 지원한다.
2. 함수 중복이 성공하기 위해서는 중복된 함수들의 이름이 같아야 하고, 이들의 매개 변수 타입이나 개수가 달라야 한다.
3. 함수 중복과 중복된 함수에 대한 호출은 모두 컴파일러에 의해 처리된다.
4. 소멸자는 매개변수를 가지지 않기 때문에 함수 중복이 없다.
5. 생성자 함수 중복을 통해 객체를 생성하는 방법을 다양화 한다.
```

#### 디폴트 매개 변수
```markdown
1. 디폴트 매개 변수란 함수의 호출문에서 매개변수에 값을 전달하지 않는 경우, 디폴트 값으로 설정된 값을 받도록 선언된 매개 변수 이다.
2. 디폴트 매개 변수를 이용하면 중복된 함수들을 하나의 함수로 작성할 수 있다.
3. 디폴트 매개 변수는 보통 매개 변수가 모두 선언된 뒤에 선언되어야 한다.
```

#### 함수 중복의 모호성
```markdown
1. 중복된 함수를 호출하는 경우, 호출문이 어떤 함수를 호출하는지 컴파일러가 처리하지 못하는 모호한 경우가 있다.
2. 형 변환으로 인한 모호성, 참조 매개 변수로 인한 모호성, 디폴트 매개 변수로 인한 모호성 등이 있다.
```

#### static 멤버
```markdown
1. static 멤버는 멤버 선언 시 static 지정자로 선언한다.
2. static 멤버는 객체의 생성과 상관없이 프로그렘이 시작할 때 생성되고, 프로그렘이 종료할 때 소멸된다.
3. static 멤버는 한 클래스에 하나만 생성되므로 클래스 멤버라고도 부르며, 클래스의 모든 객체들에 의해 공유된다.
4. non-static 멤버는 static 멤버가 아닌 보통 멤버로서, 클래스의 객체가 생성될 때 객체 내에 생성되고 객체가 소멸할 때 함께 소멸 된다.
5. static 멤버 함수는 static 멤버 함수나 변수만 접근할 수 있으며, non-static 멤버를 접근할 수 없다. 함수 내의 지역 변수를 접근하는 것은 문제없다.
6. non-static 멤버 함수는 static 멤버나 non-static 멤버 모두 정상적으로 접근 가능하다.
7. static 멤버 함수는 함수의 코드 내에서 this를 사용할 수 없다.
8. static 멤버를 접근하는 방법은 다음 세 가지가 있다.
	객체이름.static멤버
	객체포인터->static멤버 
	클래스명::static멤버
9. static 멤버 변수에 대해, 반드시 클래스 바깥에 static 멤버 변수의 메모리를 할당하는 전역 변수 선언문을 작성해야 한다.
	int Person::sharedMoney = 10; //sharedMoney가 Person class에 static으로 선언되어 있음
전역 변수나 전역 함수는 static을 사용하여 클래스로 캡슐화 할 수 있으며, static멤버 변수는 개체 사이에 공유 변수로 활용된다
```
# 프렌드와 연산자 중복
#### C++ 프렌드 개념
```markdown
1. 클래스 의 모든 멤버를 접근할 수 있도록 허용된 외부 함수나 다른 클래스의 멤버 함수를 프렌드 함수 라고 부른다.
2. 프렌드 함수는 friend 키워드를 이용하며 선언한다.
3. 프렌드 함수는 클래스의 멤버 함수가 아니다.
4. 프렌드는 클래스 내의 아무 위치에나 선언하면 된다.
5. 프렌드로 선언할 수 있는 종류는 외부 함수, 다른 클래스의 멤버 함수, 다른 클래스 전체로 3가지 이다.
6. 프렌드는 클래스의 멤버로 선언하기에는 부적합하지만, 특별한 사유로 클래스의 모든 멤버에 대한 접근 권한이 필요한 함수의 경우에 활용된다.
```

#### 연산자 중복과 프렌드
```markdown
1. 사용자는 C++기본 연산자에 대해, 피연산자가 다른 경우 새로운 연산을 하도록 재 정의할 수 있으며, 이를 연산자 중복 이라고 부른다.
2. C++의 기본 연산자가 아닌 새로운 기호를 연산자로 만들 수 없다.
3. 모든 C++의 연산자 기호를 중복하여 새로운 연산을 정의할 수 있는 것은 아니다.
4. 연산자 중복은 연산자 함수의 구현을 통해 이루어 진다. 예를 들어 cout <<'a' 에서 << 연산자도 ostream클래스에서 스트림에 문자를 출력하도록 재정의된 함수이다.
5. 연산자 함수의 원형은 다음과 같이 operator 뒤에 연산자 기호와 ()를 붙여 선언한다. 
	Circle operator+(Circle op2);     
	CIrcle donut(10);
	donut = donut +3;
7. 연산자 함수는 클래스의 멤버 함수로 구현할 수 있고, 외부 함수로 구현하고 클래스에 프렌드로 선언하여 작동하게 할 수 있다.
```
#### 이항 연산자 중복
```markdown
1. 피연산자가 두개인 +.-, +=, ==,<등 많은 이항 연산자를 중복할 수 있다.
```
#### 단항 연산자 중복
```markdown
1. 단항 연산자는 ! , ~, ++등 피연산자가 하나인 연산자이다.
2. 단항 연산자 ++, --는 ++op, op++와 같이 전위 연산자로 사용되기도 하고 후위 연산자로 사용되기도 하므로 연산자 중복 시 이들을 구분해야 한다. ++ 연산자의 경우 전위 연산자와 후위 연산자를 Circle 클래스에 선언하면 다음과 같다.
	Circle& operator++(); //전위 연산자
	Circle operator++(int x); //후위 연산자
```
#### 참조를 리턴하는 연산자 중복
```markdown
1. +=, <<, 전위연산자 ++, -- 등의 연산자는 참조를 리턴하도록 작성되어야 한다.
```
# 상속
#### 상속의 개념
```markdown
1. 객체 지향 언어에서 말하는 상속은 부모의 유전자가 자식에게 물려지는 것과 같다.
2. 중복된 기능을 가진 여러 클래스들을 상속 관계로 설정하면 클래스를 간소화할 수 있다.
3. 상속은 클래스들을 계층적으로 분류하여 관리를 용이하게 한다.
4. 상속은 부모 클래스의 재사용을 통해 소프트웨어 생산성을 향상시킨다.
5. 부모 클래스를 기본 클래스. 자식 클래스를 파생 클래스 라고 부른다.
```

#### 클래스 상속과 객체
```markdown
1. C++에서 파생 클래스 Derived는 다음과 같이 선언한다
	class Derived : Public Base { };	
2. 파생 클래스의 객체는 파생 클래스의 멤버와 기본클래싀 멤버를 모두 가진다.
```

#### 상속과 객체 포인터
```markdown
1. 기본 클래스의 포인터로 파생 객체를 가리키는 것을 업 캐스팅이라고 한다.
2. 업 캐스팅된 포인터로 객체의 기본 클래스 멤버만 접근할 수 있다.
3. 파생 클래스의 포인터에 기본 클래스 타입의 주소가 치환되는 것을 다운 캐스팅이라고 한다.
```

#### protected 접근 지정
```markdown
1. 기본 클래스의 protected 멤버는 파생 클래스를 제외한 다른 클래스나 외부 함수에서 접근할 수 없다.
```

#### 상속과 생성자,  소멸자
```markdown
1. 파생 클래스의 생성자는 기본 클래스의 생성자를 먼저 호출한 후, 자신의 생성자 코드를 실행한다. 결국 기본 클래스의 생성자가 파생 클래스의 생성자 보다 먼저 실행된다.
2. 파생 클래스의 소멸자는 자신이 먼저 실행한 후 기본 클래스의 소멸자를 호출한다. 결국 파생클래스, 기본 클래스의 순으로 소멸자가 실행한다.
3. 파생 클래스 생성자에서 기본 클래스의 생성자를 명시적으로 선택하지 않으면, 컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 호출하도록 컴파일한다.
```

#### 상속의 종류
```markdown
1. 기본 클래스를 상속 받을 때 , public 상속, private 상속, protected 상속의 3가지 방법이 있다.
2. public 상속은 기본 클래스에 선언된 접근 지정이 그대로 상속되며, protected 상속은 기본 클래스의 protected, public 멤버가 모두 protected 속성으로 변경되어 상속되며, private 상속은 protected, public 멤버가 모두 private속성으로 변경 되어 상속된다.
```

#### 다중 상속
```markdown
1. C++는 다중 상속을 허용한다. 다음은 다중 상속 사례이다.
	class MusicPhone : public MP3, public MobilPhone{ }; 
2. 다중 상속을 받은 파생 클래스의 객체가 생성될 때, 기본 클래스의 멤버가 중복하여 공간을 차지하는 문제가 발생할 수 있으며, 이 문제는 가상 상속을 통해 해결된다.
```

#### 가상 상속
```markdown
1. 가상 상속은 virtual 키워드를 이용한 상속이며, 파생클래스의 객체가 생성될 때 이미 공간을 할당 받은 기본 클래스의 멤버에 대해 공간을 할당하지 않도록 하는 지시 이다. 
```
# 가상 함수와 추상 클래스
#### 상속 관계에서의 함수 재정의
```markdown
1. 파생 클래스에 기본 클래스와 동일한 형식의 함수가 중복 작성된 경우, 기본 클래스에 대한 포인터로는 기본 클래스에 선언된 함수를 호출하고, 파생 클래스에 대한 포인터로는 파생 클래스에 선언된 함수를 호출한다.
```

#### 가상 함수와 오버라이딩
```markdown
1. 가상 함수란 virtual 키워드로 선언된 멤버 함수로서, 컴파일러에게 자신에 대한 호출을 실행 시간까지 미루도록 지시한다.
2. 파생 클래스에서 기본 클래스의 가상 함수와 동일한 타입의 함수를 재작성하는 것을 함수 오버라이딩이라고 부른다.
3. 파생 클래스에서 가상 함수를 오버라이딩 하고 기본 클래스의 포인터로 파생 클래스의 객체를 가리킬 때, 가상 함수를 호출하면 무조건 파생 클래스에서 오버라이딩한 가상 함수가 호출 된다. 이것을 동적 바인딩이라고 부른다.
4. 가상 함수의 이름, 매개변수 개수와 타입, 리턴 타입까지 일치할 때 오버라이딩이 성공한다.
5. 가상 함수의 virtual 선언은 상속되므로 오버라이딩 시 virtual을 생략할 수 있다.
6. 파생 클래스에서 범위 지정 연산자 :: 를 사용하면 기본 클래스의 가상 함수를 강제로 호출할 수 있다. 컴파일러에 의해 정적 바인딩 된다.
7. 가상 소멸자는 virtual로 선언된 소멸자로서 사용을 권장한다. 기본 클래스에 대한 포인터를 이용하여 파생 클래스의 객체를 소멸시켜도, 소멸자가 virtual로 선언되어 있으면, 파생 클래스의 소멸자가 실행되고 뒤이어 기본 클래스의 소멸자가 실행되는 정상적인 과정이 진행된다.
8. override 키워드는 오버라이딩 하는 함수 끝에 사용하며 컴파일러로 하여금 오버라이딩이 정확한지 확인하도록 한다. final을 가상 함수의 끝에 작성하면 오버라이딩할 수 없음을 지시하고, 클래스 선언부의 클래스 이름 끝에 붙이게 되면 클래스를 상속받을 수 없음을 지시한다.
```
#### 추상 클래스
```markdown
1. 함수의 코드가 없고 선언만 있는 가상함수를 순수 가상 함수 라고 부른다.
2. 최소한 하나의 순수 가상 함수를 가진 클래스를 추상 클래스라고 부른다.
	class Shape{
	public:
		virtual void draw() = 0; // 순수 가상 함수
	};
3. 추상 클래스는 온전한 클래스가 아니므로 인스턴스를 생성할 수 없다.
	Shape shape; // 컴파일 오류
	Shape *p = new Shape(); 컴파일 오류
4. 추상 클래스에 대한 포인터는 선언할 수 없다.
5. 추상 클래스는 상속을 위한 기본 클래스로서 파생 클래스에서 구현할 함수의 원형을 알려주는 인터페이스 역할을 한다.
6. 추상 클래스 구현은 파생 클래스에서 추상 클래스를 상속받아 순수 가상 함수를 모두 구현하는 것이다.
7. 추상 클래스를 상속받은 클래스가 순수 가상 함수를 모두 구현하지 않는 경우 추상 클래스가 된다.
8. 추상 클래스로 기본 방향을 잡아 놓고 파생 클래스에서 그 목적에 따라 서로 다르게 구현할 수 있으므로, 프로그램 설계와 구현을 분리할 수 있다.
```
